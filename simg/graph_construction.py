import json
import logging
from typing import Mapping, List, Tuple, Optional

import numpy as np
import pandas as pd

import torch
from torch_geometric.data import Data

from .utils import one_hot_encoding
from simg.data import get_connectivity_info, block_diagonal
from .config import *


def contains_errors(nbo_data: Mapping) -> bool:
    """Checks if the NBO data contains errors.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).

    Returns
    -------
    bool
        True if the NBO data contains errors, False otherwise.
    """

    # check if there's no missing information
    if nbo_data['hybridization_character'] == [] or nbo_data['perturbation_energy'] == []:
        return True

    # check number of types orbitals
    orbitals = pd.DataFrame(nbo_data["hybridization_character"][1])
    if (orbitals['type'] == 'BD').sum() != (orbitals['type'] == 'BD*').sum():
        return True

    # check ordering
    if (orbitals['atom 1 number'].iloc[:len(orbitals) // 2].values != orbitals['atom 1 number'].iloc[
                                                                      len(orbitals) // 2:].values).any():
        return True
    if (orbitals['atom 2 number'].iloc[:len(orbitals) // 2].values != orbitals['atom 2 number'].iloc[
                                                                      len(orbitals) // 2:].values).any():
        return True

    return False


def get_features(atom_data: Mapping, lone_pair_data: Mapping, bond_data: Mapping) -> np.ndarray:
    """Gets the features for the graph from atom, lone pair and bond data.

    Parameters
    ----------
    atom_data: Mapping
        The atom data dictionary, generated by the `get_atom_data` function.
    lone_pair_data: Mapping
        The lone pair data dictionary, generated by the `get_lone_pair_data` function.
    bond_data: Mapping
        The bond data dictionary, generated by the `get_bond_data` function.

    Returns
    -------
    np.ndarray
        The stacked features for the homogenous graph.
    """

    x = np.zeros((
        atom_data['n'] + lone_pair_data['n'] + bond_data['n']['orbital'],
        atom_data['n_descriptors'] + lone_pair_data['n_descriptors'] + bond_data['n_descriptors'][
            'orbital'] + NUMBER_OF_NODE_TYPES
    ))

    # ATOMS

    x[:atom_data['n'], :atom_data['n_descriptors']] = atom_data['descriptors']
    x[:atom_data['n'], -3] = 1

    # LONE PAIRS
    # Atomic on-hot; is p; n_neighbours
    if lone_pair_data['n'] > 0:
        x[
        atom_data['n']:atom_data['n'] + lone_pair_data['n'],
        atom_data['n_descriptors']:atom_data['n_descriptors'] + atom_data['n_descriptors']
        ] = lone_pair_data['descriptors']['atom']

        x[
        atom_data['n']:atom_data['n'] + lone_pair_data['n'],
        atom_data['n_descriptors'] + atom_data['n_descriptors']
        ] = lone_pair_data['descriptors']['is_p']

        x[
        atom_data['n']:atom_data['n'] + lone_pair_data['n'],
        atom_data['n_descriptors'] + atom_data['n_descriptors'] + 1
        ] = lone_pair_data['descriptors']['n_neighbours']

        x[atom_data['n']:atom_data['n'] + lone_pair_data['n'], -2] = 1

    # BONDS
    # One-hot bond, orbital length, is_p

    atoms_and_lps_n = atom_data['n'] + lone_pair_data['n']
    atoms_and_lps_n_descriptors = atom_data['n_descriptors'] + lone_pair_data['n_descriptors']

    x[
    atoms_and_lps_n:atoms_and_lps_n + bond_data['n']['orbital'],
    atoms_and_lps_n_descriptors
    ] = bond_data['descriptors']['orbital_length']

    x[
    atoms_and_lps_n:atoms_and_lps_n + bond_data['n']['orbital'],
    atoms_and_lps_n_descriptors + 1
    ] = bond_data['descriptors']['is_p']

    x[atoms_and_lps_n:atoms_and_lps_n + bond_data['n']['orbital'], -1] = 1

    return x


def get_targets(atom_data, lone_pair_data, bond_data) -> np.ndarray:
    """Gets the targets for the graph from atom, lone pair and bond data.

    Parameters
    ----------
    atom_data: Mapping
        The atom data dictionary, generated by the `get_atom_data` function.
    lone_pair_data: Mapping
        The lone pair data dictionary, generated by the `get_lone_pair_data` function.
    bond_data: Mapping
        The bond data dictionary, generated by the `get_bond_data` function.

    Returns
    -------
    np.ndarray
        The stacked targets for the homogenous graph.
    """
    y = np.zeros((
        atom_data['n'] + lone_pair_data['n'] + bond_data['n']['orbital'],
        atom_data['targets'].shape[1] + lone_pair_data['targets'].shape[1] + bond_data['targets'].shape[1]
    ))

    # ATOM
    y[:atom_data['n'], :atom_data['targets'].shape[1]] = atom_data['targets']

    # LONE PAIR
    y[
    atom_data['n']:atom_data['n'] + lone_pair_data['n'],
    atom_data['targets'].shape[1]:atom_data['targets'].shape[1] + lone_pair_data['targets'].shape[1]
    ] = lone_pair_data['targets']

    # BOND
    atom_and_lps_n = atom_data['n'] + lone_pair_data['n']
    atom_and_lps_n_targets = atom_data['targets'].shape[1] + lone_pair_data['targets'].shape[1]

    y[
    atom_and_lps_n:atom_and_lps_n + bond_data['n']['orbital'],
    atom_and_lps_n_targets: atom_and_lps_n_targets + bond_data['targets'].shape[1]
    ] = bond_data['targets']

    return y


def get_edges(atom_data, lone_pair_data, bond_data, x):
    """Gets the edges for the graph from atom, lone pair and bond data.

    Parameters
    ----------
    atom_data: Mapping
        The atom data dictionary, generated by the `get_atom_data` function.
    lone_pair_data: Mapping
        The lone pair data dictionary, generated by the `get_lone_pair_data` function.
    bond_data: Mapping
        The bond data dictionary, generated by the `get_bond_data` function.
    x: np.ndarray
        The stacked features for the homogenous graph.

    Returns
    -------
    np.ndarray
        The stacked edges for the homogenous graph.
    """
    edge_index = []
    edge_attr = np.zeros((
        bond_data['n']['edge'] + lone_pair_data['n'] + bond_data['n']['orbital'] * 2,
        NUMBER_OF_BOND_TYPES + lone_pair_data['n_descriptors'] + bond_data['n_descriptors'][
            'orbital'] + NUMBER_OF_EDGE_TYPES
    ))

    # ATOM-ATOM
    for atom_A, atom_B, order in bond_data['connectivity']:
        edge_index.append([atom_A, atom_B])

    edge_attr[:bond_data['n']['edge'], :NUMBER_OF_BOND_TYPES] = bond_data['descriptors']['one-hot']
    edge_attr[:bond_data['n']['edge'], -3] = 1

    # ATOM-LONE PAIR
    for lone_pair_index, atom in enumerate(lone_pair_data['lone_pair_atoms']):
        edge_index.append([atom, atom_data['n'] + lone_pair_index])

    edge_attr[
    bond_data['n']['edge']: bond_data['n']['edge'] + lone_pair_data['n'],
    NUMBER_OF_BOND_TYPES: NUMBER_OF_BOND_TYPES + lone_pair_data['n_descriptors'],
    ] = x[
        atom_data['n']:atom_data['n'] + lone_pair_data['n'],
        atom_data['n_descriptors']:atom_data['n_descriptors'] + lone_pair_data['n_descriptors']
        ]
    edge_attr[bond_data['n']['edge']: bond_data['n']['edge'] + lone_pair_data['n'], -2] = 1

    # ATOM-BOND
    for i, atoms in enumerate(bond_data['atom_indexes']):
        for atom in atoms:
            edge_index.append(
                [atom, atom_data['n'] + lone_pair_data['n'] + i]
            )

    edges_and_lps_n = bond_data['n']['edge'] + lone_pair_data['n']
    edges_and_lps_n_descriptors = NUMBER_OF_BOND_TYPES + lone_pair_data['n_descriptors']

    for pair_row in range(2):
        edge_attr[
        edges_and_lps_n + pair_row:edges_and_lps_n + bond_data['n']['orbital'] * 2:2,
        edges_and_lps_n_descriptors] = bond_data['descriptors']['orbital_length']

        edge_attr[
        edges_and_lps_n + pair_row:edges_and_lps_n + bond_data['n']['orbital'] * 2:2,
        edges_and_lps_n_descriptors + 1] = bond_data['descriptors']['is_p']

    edge_attr[edges_and_lps_n:edges_and_lps_n + bond_data['n']['orbital'] * 2, -1] = 1

    # Inverse
    edge_index += [[j, i] for i, j in edge_index]
    edge_index = np.array(edge_index).astype(int).T
    edge_attr = np.vstack([edge_attr, edge_attr])

    return edge_index, edge_attr


def get_xyz_data(atom_coordinates: List[np.ndarray], lone_pair_atoms: List[int], bond_atom_indexes) -> np.ndarray:
    """Gets the xyz data for each the graph, including bond and lone pair nodes.

    Parameters
    ----------
    atom_coordinates: List[np.ndarray]
        The list of atom coordinates.
    lone_pair_atoms: List[int]
        The lone pair atoms.
    bond_atom_indexes: np.ndarray
        The bond atom indexes.

    Returns
    -------
    np.ndarray
        The xyz data for each node in the graph.
    """
    xyz_data = atom_coordinates.copy()

    xyz_data += [xyz_data[i] for i in lone_pair_atoms]
    xyz_data += [(xyz_data[i] + xyz_data[j]) / 2 for i, j in bond_atom_indexes]

    xyz_data = np.vstack(xyz_data)
    return xyz_data


def get_vector_data(atom_data: Mapping, lone_pair_data: Mapping, bond_data: Mapping) -> np.ndarray:
    """Gets the orientation vectors for the nodes in the  graph.

    Parameters
    ----------
    atom_data: Mapping
        The atom data dictionary, generated by the `get_atom_data` function.
    lone_pair_data: Mapping
        The lone pair data dictionary, generated by the `get_lone_pair_data` function.
    bond_data: Mapping
        The bond data dictionary, generated by the `get_bond_data` function.

    Returns
    -------
    np.ndarray
        The orientation vectors for the nodes in the graph.
    """
    vector_data = np.zeros((atom_data['n'] + lone_pair_data['n'], 3))
    vector_data = np.vstack((vector_data, bond_data['bond_vectors']))

    return vector_data


def get_atom_targets(nbo_data: Mapping, config: Mapping) -> pd.DataFrame:
    """Gets the targets for the atom nodes.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    config: Mapping
        The configs (from corresponding yaml file).

    Returns
    -------
    pd.DataFrame
        The targets for the atom nodes.
    """
    natural_populations = nbo_data["natural_populations"][0]
    natural_populations = pd.DataFrame(natural_populations)
    natural_populations = natural_populations[config['target_calculation']['atom_targets']].values

    return natural_populations


def get_atom_data(nbo_data: Mapping, xyz_data: List[str], symbols: List[str], config: Mapping,
                  need_targets: bool) -> Mapping:
    """Gets the atom data for the graph.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    xyz_data: List[str]
        The xyz data for the graph.
    symbols: List[str]
        The list of symbols for the atoms.
    config: Mapping
        The configs (from corresponding yaml file).
    need_targets: bool
        Whether or not to include targets.

    Returns
    -------
    Mapping
        The atom data dictionary.
    """
    if not config['descriptor_calculation']['atom_descriptors'] in ['one-hot']:
        raise NotImplementedError("This atom descriptor is not implemented yet.")

    return {
        'descriptors': np.array(
            [one_hot_encoding(symbol, config['atoms']) for symbol in symbols]),
        'targets': get_atom_targets(nbo_data, config) if need_targets else None,
        'coordinates': [np.array([float(item) for item in line.strip().split('\t')[1:]]) for line in xyz_data],
        'n': len(xyz_data),
        'n_descriptors': len(config['atoms'])
    }


def get_lone_pair_data(nbo_data: Mapping, atom_descriptors: np.ndarray, config: Mapping,
                       lp_generated: Mapping) -> Mapping:
    """Gets the lone pair data for the graph.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    atom_descriptors: np.ndarray
        The atom descriptors for the graph.
    config: Mapping
        The configs (from corresponding yaml file).
    lp_generated: Mapping
        The lone pair data dictionary from LP prediction module.

    Returns
    -------
    Mapping
        The lone pair data dictionary.
    """
    zero_output = {
        'descriptors': {
            'atom': [],
            'is_p': [],
            'n_neighbours': []
        },
        'targets': np.zeros((0, len(config["target_calculation"]["lone_pair_targets"]))),
        'lone_pair_atoms': [],
        'n': 0,
        'n_descriptors': len(config['atoms']) + 2,
        'index_mappers': [{}, {}]
    }

    if lp_generated is None:
        lone_pairs = pd.DataFrame(nbo_data["hybridization_character"][0])

        if len(lone_pairs) == 0:
            return zero_output

        lp_idx2atom_idx = list(lone_pairs["atom number"].astype(int) - 1)
        targets = lone_pairs[
            config["target_calculation"]["lone_pair_targets"]
        ].values

        is_p = lone_pairs["p"].astype(float) - lone_pairs["s"].astype(float)
        is_p = is_p > config['descriptor_calculation']['lone_pair_descriptors']['p_threshold']

        bond_idx2lp_idx = dict(
            zip(np.arange(len(lone_pairs)), list(lone_pairs["bond index"].astype(int)))
        )
        lp_idx2bond_idx = dict(
            zip(list(lone_pairs["bond index"].astype(int)), np.arange(len(lone_pairs)))
        )

    else:
        if len(lp_generated['lp_idx2atom_idx']) == 0:
            return zero_output

        lp_idx2atom_idx = lp_generated['lp_idx2atom_idx']
        targets = None

        is_p = lp_generated['is_p']

        bond_idx2lp_idx = {}
        lp_idx2bond_idx = {}

    neighbours_count = np.array([lp_idx2atom_idx.count(atom) for atom in lp_idx2atom_idx])

    return {
        'descriptors': {
            'atom': atom_descriptors[lp_idx2atom_idx],
            'is_p': is_p,
            'n_neighbours': neighbours_count,
        },
        'targets': targets,
        'lone_pair_atoms': lp_idx2atom_idx,
        'n': len(lp_idx2atom_idx),
        'n_descriptors': len(config['atoms']) + 2,
        'index_mappers': [bond_idx2lp_idx, lp_idx2bond_idx],
    }


def split_bond_data(nbo_data: Mapping) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Splits the orbital data into bonding and anti-bonding orbitals.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).

    Returns
    -------
    Tuple[pd.DataFrame, pd.DataFrame]
        The bonding and anti-bonding orbitals.
    """
    orbitals = pd.DataFrame(
        nbo_data["hybridization_character"][1]
    )
    orbitals[["atom 1 number", "atom 2 number"]] = orbitals[
        ["atom 1 number", "atom 2 number"]
    ].astype(int)

    orbitals[["atom 1 number", "atom 2 number"]] -= 1

    return orbitals.head(len(orbitals) // 2), orbitals.tail(len(orbitals) // 2)


def get_bond_targets(orbitals: pd.DataFrame, config: Mapping) -> pd.DataFrame:
    """Gets the bond node targets.

    Parameters
    ----------
    orbitals: pd.DataFrame
        The bonding orbitals data.
    config: Mapping
        The configs (from corresponding yaml file).

    Returns
    -------
    pd.DataFrame
        The bond node targets.
    """
    for t in ['s', 'p', 'd', 'f']:
        orbitals[t] = abs(
            orbitals[f'atom 1 {t}'].astype(float) - orbitals[f'atom 2 {t}'].astype(float)
        ) / 100

    orbitals['pol_diff'] = abs(
        orbitals['atom 1 polarization'].astype(float) - orbitals['atom 2 polarization'].astype(float)
    ) / 100

    orbitals['pol_coeff_diff'] = abs(
        orbitals['atom 1 pol coeff'].astype(float) - orbitals['atom 2 pol coeff'].astype(float)
    )

    return orbitals[config['target_calculation']['bond_targets']].astype(float)


def get_bond_data(nbo_data: Mapping, xyz_data: List[str], atom_coordinates: List[np.ndarray],
                  config: Mapping, need_targets: bool) -> Mapping:
    """Extracts bond data from NBO data

    IMPORTANT: there are actually two types of bonds: edges in the graph and corresponding orbitals,
    number of them is not equal, and they should be treated separately. Bond-edges come from the connectivity
    matrix, while bond-orbitals come from the NBO data.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    xyz_data: List[str]
        The xyz data.
    atom_coordinates: List[np.ndarray]
        The atom coordinates.
    config: Mapping
        The configs (from corresponding yaml file).
    need_targets: bool
        Whether to return targets.

    Returns
    -------
    Mapping
        The bond data.
    """
    orbitals, _ = split_bond_data(nbo_data)

    orbital_lengths = [np.linalg.norm(
        atom_coordinates[row['atom 1 number']] - atom_coordinates[row['atom 2 number']]
    ) for _, row in orbitals.iterrows()]

    is_p = orbitals[["atom 1 p", "atom 2 p"]].astype(float).mean(axis=1).values
    is_p = is_p > config['descriptor_calculation']['bond_descriptors']['p_threshold']

    bond_atom_indexes = [(row['atom 1 number'], row['atom 2 number']) for _, row in orbitals.iterrows()]

    connectivity = get_connectivity_info(xyz_data)
    bond_types = np.zeros((len(connectivity), NUMBER_OF_BOND_TYPES))
    for i, (_, _, bond_type) in enumerate(connectivity):
        bond_types[i, bond_type - 1] = 1

    edge_lengths = [np.linalg.norm(
        atom_coordinates[atom_A] - atom_coordinates[atom_B]
    ) for atom_A, atom_B, _ in connectivity]

    bond_vectors = [atom_coordinates[atom_A] - atom_coordinates[atom_B] for atom_A, atom_B in bond_atom_indexes]

    # Get a2b data

    a2b = []
    b2a = []
    a2b_targets = []

    for orbital_idx, (_, row) in enumerate(orbitals.iterrows()):
        for i in range(1, 3):
            a2b.append([row[f"atom {i} number"], orbital_idx])
            b2a.append([orbital_idx, row[f"atom {i} number"]])

            a2b_targets.append(row[[
                f"atom {i} s", f"atom {i} p", f"atom {i} d", f"atom {i} f",
                f"atom {i} polarization", f"atom {i} pol coeff"
            ]])

    a2b_targets = np.array(a2b_targets).astype(float)
    a2b_targets[:, :5] /= PERCENT_NORMALIZER

    return {
        'descriptors': {
            'one-hot': bond_types,
            'edge_length': edge_lengths,
            'orbital_length': orbital_lengths,
            'is_p': is_p
        },
        'targets': get_bond_targets(orbitals, config).values if need_targets else None,
        'atom_indexes': bond_atom_indexes,
        'connectivity': connectivity,
        'bond_vectors': bond_vectors,
        'a2b_data': {
            'a2b': a2b,
            'b2a': b2a,
            'a2b_targets': a2b_targets
        },
        'n_descriptors': {
            'edge': NUMBER_OF_BOND_TYPES + 2,
            'orbital': 2,
        },
        'n': {
            'edge': len(connectivity),
            'orbital': len(orbitals)
        }
    }


def get_orbital_interaction_features(nbo_data: Mapping, config: Mapping) -> Mapping:
    """Gets the orbital interaction features.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    config: Mapping
        The configs (from corresponding yaml file).

    Returns
    -------
    Mapping
        The orbital interaction features.
    """
    indexes = ["donor bond index", "acceptor bond index"]

    interaction_data = pd.DataFrame(nbo_data["perturbation_energy"][0])

    if len(interaction_data) == 0:
        return {"edges": [], "data": np.zeros((0, 3))}

    for prohibited_type in PROHIBITED_INTERACTION_TYPES:
        interaction_data = interaction_data[
            (interaction_data["donor type"] != prohibited_type)
            & (interaction_data["acceptor type"] != prohibited_type)
            ]

    edges = interaction_data[indexes].to_numpy().tolist()

    interaction_data['perturbation energy'] /= PERTURBATION_ENERGY_NORMALIZER

    return {
        "edges": edges,
        "data": interaction_data[config['target_calculation']['orbital_interaction_targets']].values
    }


def get_interaction_data(nbo_data: Mapping, atom_data: Mapping, lone_pair_data: Mapping,
                         bond_data: Mapping, config: Mapping) -> Tuple[np.ndarray, np.ndarray]:
    """Gets the interaction data.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    atom_data: Mapping
        The atom data.
    lone_pair_data: Mapping
        The lone pair data.
    bond_data: Mapping
        The bond data.
    config: Mapping
        The configs (from corresponding yaml file).

    Returns
    -------
    Tuple[np.ndarray, np.ndarray]
        Indexes of interacting nodes and corresponding targets
    """
    bond_idx2bond = dict(
        zip(
            pd.DataFrame(nbo_data["hybridization_character"][1])["bond index"]
                .astype(int)
                .tolist(),
                list(range(bond_data['n']['orbital'])) * 2,
        )
    )
    orbital_interaction_data = get_orbital_interaction_features(nbo_data, config)

    def get_type(bond_idx):
        if bond_idx in lone_pair_data["index_mappers"][1]:
            return "lone_pair"
        else:
            return "bond"

    def get_idx(bond_idx, bond_type):
        if bond_type == "lone_pair":
            return lone_pair_data["index_mappers"][1][bond_idx]
        else:
            return bond_idx2bond[bond_idx]

    offset = {
        'bond': atom_data['n'] + lone_pair_data['n'],
        'lone_pair': atom_data['n']
    }

    interactions = []

    for interaction_idx, (donor_bond_idx, acceptor_bond_idx) in enumerate(
            orbital_interaction_data["edges"]
    ):
        donor_bond_idx_type = get_type(donor_bond_idx)
        donor_bond_idx_relative = get_idx(donor_bond_idx, donor_bond_idx_type)
        donor_bond_idx_relative += offset[donor_bond_idx_type]

        acceptor_bond_idx_type = get_type(acceptor_bond_idx)
        acceptor_bond_idx_relative = get_idx(acceptor_bond_idx, acceptor_bond_idx_type)
        acceptor_bond_idx_relative += offset[acceptor_bond_idx_type]

        interactions.append((donor_bond_idx_relative, acceptor_bond_idx_relative))

    targets = orbital_interaction_data['data']

    return np.array(interactions).astype(int).T, targets


def get_a2b(atom_data: Mapping, lone_pair_data: Mapping, bond_data: Mapping):
    """Gets the atom-to-bond relationship data.

    Parameters
    ----------
    atom_data: Mapping
        The atom data.
    lone_pair_data: Mapping
        The lone pair data.
    bond_data: Mapping
        The bond data.

    Returns
    -------
    Tuple[np.ndarray, np.ndarray]
        Indexes of the interaction atoms and bonds and corresponding targets
    """
    a2b_index = bond_data['a2b_data']['a2b']
    a2b_index = [(atom_idx, bond_idx + atom_data['n'] + lone_pair_data['n']) for atom_idx, bond_idx in a2b_index]

    return np.array(a2b_index).astype(int).T, bond_data['a2b_data']['a2b_targets']


def construct_NBO_graph(cmpd: List[str], config: Mapping, need_targets: Optional[bool] = True,
                        lp_generated: Optional[Mapping] = None) -> Data:
    """Processes a compound's NBO data and returns a graph.

    Parameters
    ----------
    cmpd: List[str]
        First line: NBO data; other lines: xyz data.
    config: Mapping
        The configs (from corresponding yaml file).
    need_targets: bool, optional
        Whether to return the targets.
    lp_generated: Mapping, optional
        The lone pair data from LP model.

    Returns
    -------
    Data
        The graph data.
    """

    nbo_data = json.loads(cmpd[0])
    xyz_data, qm9_id = cmpd[1:-1], cmpd[-1]
    return construct_NBO_graph_parsed(nbo_data, xyz_data, qm9_id, config, need_targets, lp_generated)


def construct_NBO_graph_parsed(nbo_data: Mapping, xyz_data: List[str], qm9_id: str, config: Mapping,
                               need_targets: bool, lp_generated: Mapping) -> Data:
    """Processes a compound's NBO data and returns a graph.

    Parameters
    ----------
    nbo_data: Mapping
        The NBO data (as parsed from QC data).
    xyz_data: List[str]
        The xyz data.
    qm9_id: str
        The QM9 ID.
    config: Mapping
        The configs (from corresponding yaml file).
    need_targets: bool
        Whether to return the targets.
    lp_generated: Mapping
        The lone pair data from LP model.

    Returns
    -------
    Data
        The graph data.
    """
    symbols = [line.split('\t')[0] for line in xyz_data]

    if nbo_data and contains_errors(nbo_data):
        logging.warning(f"IGNORING: Checks has failed for compound with QM9 ID {qm9_id}")
        return None

    atom_data = get_atom_data(nbo_data, xyz_data, symbols, config, need_targets)
    lone_pair_data = get_lone_pair_data(nbo_data, atom_data['descriptors'], config, lp_generated)
    bond_data = get_bond_data(nbo_data, xyz_data, atom_data['coordinates'], config, need_targets)

    graph = Data()

    graph.qm9_id = qm9_id.strip()

    graph.x = get_features(atom_data, lone_pair_data, bond_data)
    if need_targets:
        graph.y = get_targets(atom_data, lone_pair_data, bond_data)
    else:
        graph.y = []
    graph.edge_index, graph.edge_attr = get_edges(atom_data, lone_pair_data, bond_data, graph.x)
    if need_targets:
        graph.interaction_edge_index, graph.interaction_targets = get_interaction_data(
            nbo_data, atom_data, lone_pair_data, bond_data, config
        )
    else:
        graph.interaction_edge_index, graph.interaction_targets = np.zeros((2, 0)), np.zeros(0)
    graph.a2b_index, graph.a2b_targets = get_a2b(atom_data, lone_pair_data, bond_data)

    graph.is_atom = np.array([1] * atom_data['n'] + [0] * lone_pair_data['n'] + [0] * bond_data['n']['orbital'])
    graph.is_lp = np.array([0] * atom_data['n'] + [1] * lone_pair_data['n'] + [0] * bond_data['n']['orbital'])
    graph.is_bond = np.array([0] * atom_data['n'] + [0] * lone_pair_data['n'] + [1] * bond_data['n']['orbital'])

    graph.xyz_data = get_xyz_data(atom_data['coordinates'], lone_pair_data['lone_pair_atoms'],
                                  bond_data['atom_indexes'])
    graph.vector_data = get_vector_data(atom_data, lone_pair_data, bond_data)

    symbols = symbols + ['LP'] * int(sum(graph.is_lp).item()) + ['BND'] * int(sum(graph.is_bond).item())

    # convert everything to torch

    graph = Data(
        x=torch.FloatTensor(graph.x),
        y=torch.FloatTensor(graph.y),
        edge_index=torch.LongTensor(graph.edge_index),
        edge_attr=torch.FloatTensor(graph.edge_attr),
        symbol=symbols,
        is_atom=torch.Tensor(graph.is_atom),
        is_lp=torch.Tensor(graph.is_lp),
        is_bond=torch.Tensor(graph.is_bond),
        interaction_edge_index=torch.LongTensor(graph.interaction_edge_index),
        xyz_data=torch.FloatTensor(graph.xyz_data),
        vector_data=torch.FloatTensor(graph.vector_data),
        a2b_index=torch.LongTensor(graph.a2b_index),
        a2b_targets=torch.FloatTensor(graph.a2b_targets),
        interaction_targets=torch.FloatTensor(graph.interaction_targets),
        qm9_id=graph.qm9_id
    )

    return graph


def convert_NBO_graph_to_downstream(graph: Data, molecular_only: Optional[bool] = False) -> Data:
    """Converts a graph to a downstream graph.

    Parameters
    ----------
    graph: Data
        The input graph.
    molecular_only: bool, optional
        Return molecular fraph only.

    Returns
    -------
    Data
        The downstream graph.
    """
    new_graph = Data()
    new_graph.qm9_id = graph.qm9_id

    new_graph.x = torch.hstack((graph.x, graph.y))
    if molecular_only:
        new_graph.x = new_graph.x[graph.is_atom == 1]

    if not molecular_only:
        new_graph.x = block_diagonal(new_graph.x, graph.interaction_targets,
                                     new_graph.x.shape[1] + graph.interaction_targets.shape[1])

    if molecular_only:
        new_graph.edge_index = graph.edge_index
        new_graph.edge_attr = graph.edge_attr

        # Create mask for edges that are between atoms only
        edge_mask = torch.zeros(new_graph.edge_index.shape[1], dtype=torch.bool)
        edge_mask[graph.is_atom[new_graph.edge_index[0]].bool() & graph.is_atom[new_graph.edge_index[1]].bool()] = True

        new_graph.edge_index = new_graph.edge_index[:, edge_mask]
        new_graph.edge_attr = new_graph.edge_attr[edge_mask]
    else:
        new_graph.edge_index = torch.hstack((graph.edge_index, graph.a2b_index,
                                             torch.LongTensor(graph.a2b_index.numpy()[::-1].copy())))
        new_graph.edge_index = torch.hstack((new_graph.edge_index,
                                             graph.interaction_edge_index,
                                             torch.LongTensor(graph.interaction_edge_index.numpy()[::-1].copy())))

        new_graph.edge_attr = block_diagonal(graph.edge_attr, torch.vstack([graph.a2b_targets] * 2),
                                             graph.edge_attr.shape[1] + graph.a2b_targets.shape[1])
        new_graph.edge_attr = block_diagonal(new_graph.edge_attr, torch.vstack([graph.interaction_targets] * 2),
                                             new_graph.edge_attr.shape[1] + graph.interaction_targets.shape[1])

    if not molecular_only:
        new_graph.is_atom = graph.is_atom
        new_graph.is_lp = graph.is_lp
        new_graph.is_bond = graph.is_bond

    new_graph.type = graph.type
    new_graph.normalized_targets = graph.normalized_targets
    new_graph.symbol = graph.symbol

    return new_graph


def convert_LP_prediction_to_NBO(xyz_data: List[str], qm9_id: str, config: Mapping, lp_idx2atom_idx: List[int],
                                 is_p: List[int]) -> Data:
    """Converts a lone pair prediction to a NBO graph.

    Parameters
    ----------
    xyz_data: List[str]
        The xyz data.
    qm9_id: str
        The qm9 id.
    config: Mapping
        The configs (from corresponding yaml file).
    lp_idx2atom_idx: List[int]
        Indexes of atoms to which each of the lone pairs is attached.
    is_p: List[int]
        The same length as `lp_idx2atom_idx` and shows if corresponding lone pair is a p-type orbital.

    Returns
    -------
    Data
        The NBO graph.
    """
    parsed_nbo_graph = construct_NBO_graph_parsed(
        {}, xyz_data, qm9_id, config, need_targets=False,
        lp_generated={
            'lp_idx2atom_idx': lp_idx2atom_idx,
            'is_p': is_p
        }
    )
    return parsed_nbo_graph
